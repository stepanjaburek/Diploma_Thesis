# -*- coding: utf-8 -*-
"""EU_Performance_Metrics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kOM1pDrXo3hn2GkR-OiZLPVVUf4c-GjE

##Performance metrics for the NLI

# Setup
"""

import torch
from transformers import pipeline
import pandas as pd
from tqdm.notebook import tqdm
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import f1_score
from sklearn.metrics import f1_score, accuracy_score, balanced_accuracy_score, precision_score, recall_score, classification_report, matthews_corrcoef
import matplotlib.pyplot as plt
import seaborn as sns

"""# Model specification and labeling - framing"""

hypothesis_dict = {
    "Appropriateness": [
        "The speaker is concerned with identities.",
        "The argument is based on shared norms or values.",
        "The speaker focuses on what is morally appropriate.",
        "The speaker appeals to appropriate behavior."

    ],
    "Consequences": [
        "The speaker is concerned with costs and benefits.",
        "The speaker focuses on consequences.",
        "This argument is based on utility.",
        "The speaker appeals to results or effectiveness."
    ]
}

def analyze_sentiments_multi_hypothesis(df, classifier, hypothesis_dict, batch_size=16, aggregation="max"):
    import numpy as np
    results = []

    texts = df['translated_context_full'].tolist()
    num_samples = len(texts)

    for i in tqdm(range(0, num_samples, batch_size)):
        batch_texts = texts[i:i + batch_size]

        # Collect all hypotheses for the batch
        all_hypotheses = []
        for label, hyps in hypothesis_dict.items():
            all_hypotheses.extend(hyps)

        # Run multi-label zero-shot with all hypotheses at once
        batch_output = classifier(
            batch_texts,
            candidate_labels=all_hypotheses,
            hypothesis_template="{}",
            multi_label=True,
            batch_size=batch_size
        )

        for item in batch_output:
            # Create per-label aggregated scores
            aggregated_scores = {}
            all_label_scores = dict(zip(item["labels"], item["scores"]))

            for label, hyps in hypothesis_dict.items():
                scores = [all_label_scores.get(hyp, 0.0) for hyp in hyps]
                if aggregation == "max":
                    aggregated_scores[label] = max(scores)
                else:
                    aggregated_scores[label] = sum(scores) / len(scores)

            # Determine final label
            app = aggregated_scores["Appropriateness"]
            con = aggregated_scores["Consequences"]

            if app < 0.5 and con < 0.5:
                final_label = "Neither"
            elif app >= 0.5 and con >= 0.5:
                final_label = "Both"
            elif app > con:
                final_label = "Appropriateness"
            else:
                final_label = "Consequences"

            results.append({
                "Appropriateness_score": app,
                "Consequences_score": con,
                "label": final_label
            })

    return pd.DataFrame(results)

df = pd.read_excel("/content/eu_frame_test.xlsx")

model_name = "mlburnham/Political_DEBATE_large_v1.0"
device = 0 if torch.cuda.is_available() else -1
classifier = pipeline("zero-shot-classification",
                     model=model_name,
                     device=device)

results = analyze_sentiments_multi_hypothesis(
    df,
    classifier,
    hypothesis_dict,
    batch_size=16,
    aggregation="max"
)
pd.concat([df, results], axis=1).to_csv("debate_framing_eu.csv", index=False)
print("\nFraming Distribution:")
print(results["label"].value_counts())

test = pd.read_csv("/content/debate_framing_eu.csv")

"""# Performance metrics framing analysis"""

actual = test['framing']
predicted = test['label']


# F1 scores
f1_micro = f1_score(actual, predicted, average='micro')
f1_weighted = f1_score(actual, predicted, average='weighted')

# Accuracy
accuracy = accuracy_score(actual, predicted)

# Balanced accuracy (useful for imbalanced datasets)
balanced_accuracy = balanced_accuracy_score(actual, predicted)

# Precision and recall
precision = precision_score(actual, predicted, average='weighted')
recall = recall_score(actual, predicted, average='weighted')
mcc = matthews_corrcoef(actual, predicted)
print(f"\nMatthews Correlation Coefficient (MCC): {mcc:.3f}")

print(f"F1 Micro: {f1_micro:.3f}")
print(f"F1 Weighted: {f1_weighted:.3f}")
print(f"Accuracy: {accuracy:.3f}")
print(f"Balanced Accuracy: {balanced_accuracy:.3f}")
print(f"Precision: {precision:.3f}")
print(f"Recall: {recall:.3f}")

# For a detailed classification report
print("\nClassification Report:")
print(classification_report(actual, predicted))

classes = ['Consequences', 'Appropriateness', 'Both','Neither', ]
cm = confusion_matrix(actual, predicted, labels=classes)
cm
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=classes)
disp.plot()

"""# Model specification and labeling - Stance"""

def analyze_sentiments(df, classifier, classes, hypothesis, batch_size=16):
    results = []
    for i in tqdm(range(0, len(df), batch_size)):
        batch_output = classifier(
            df['translated_context_full'][i:i + batch_size].tolist(),
            classes,
            hypothesis_template=hypothesis,
            multi_label=True,
            batch_size=batch_size
        )

        for item in batch_output:
            results.append({
                'label': item['labels'][0],
                'score': item['scores'][0],
                **{f'{label}_score': score for label, score in zip(item['labels'], item['scores'])}
            })

    return pd.DataFrame(results)

df = pd.read_excel("/content/eu_test_data.xlsx")


hypothesis_template =  "The author of this text {} the European Union"
classes = [ "supports", "opposes", "is neutral towards"]
model_name = "mlburnham/Political_DEBATE_large_v1.0"
device = 0 if torch.cuda.is_available() else -1
classifier = pipeline("zero-shot-classification",
                     model=model_name,
                     device=device)

results = analyze_sentiments(df, classifier, classes, hypothesis_template)

pd.concat([df, results], axis=1).to_csv('debate_stance_eu.csv', index=False)
print("\nFraming Distribution:")
print(results["label"].value_counts())

test = pd.read_csv("/content/debate_stance_eu.csv")

"""# Performance metrics stance detection"""

classes = ['opposes', 'supports', 'is neutral towards']

actual = test['stance_human']
predicted = test['label']

# F1 scores
f1_micro = f1_score(actual, predicted, average='micro')
f1_weighted = f1_score(actual, predicted, average='weighted')


# Precision and recall
precision = precision_score(actual, predicted, average='weighted')
recall = recall_score(actual, predicted, average='weighted')

mcc = matthews_corrcoef(actual, predicted)
print(f"\nMatthews Correlation Coefficient (MCC): {mcc:.3f}")

print(f"F1 Micro: {f1_micro:.3f}")
print(f"F1 Weighted: {f1_weighted:.3f}")
print(f"Precision: {precision:.3f}")
print(f"Recall: {recall:.3f}")

# For a detailed classification report
print("\nClassification Report:")
print(classification_report(actual, predicted))

classes = ['opposes', 'supports', 'is neutral towards']
cm = confusion_matrix(actual, predicted, labels=classes)
cm
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=classes)
disp.plot()